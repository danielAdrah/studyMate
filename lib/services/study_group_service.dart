import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';

import '../model/study_group.dart';
import '../model/study_group_message.dart';
import '../model/study_session.dart';
import '../services/notification_service.dart';

class StudyGroupService {
  final FirebaseFirestore firestore = FirebaseFirestore.instance;
  final FirebaseAuth auth = FirebaseAuth.instance;

  // Create a new study group
  Future<String> createStudyGroup(
    String name,
    String courseId,
    String courseName,
    String? description,
  ) async {
    try {
      final currentUserID = auth.currentUser!.uid;

      final groupData = StudyGroup(
        id: '', // Will be generated by Firestore
        name: name,
        courseId: courseId,
        courseName: courseName,
        memberIds: [currentUserID],
        creatorId: currentUserID,
        createdAt: Timestamp.now(),
        description: description,
      );

      final docRef =
          await firestore.collection('study_groups').add(groupData.toMap());

      // Add current user to group members
      await docRef.update({'id': docRef.id});

      return docRef.id;
    } catch (e) {
      print('Error creating study group: $e');
      rethrow;
    }
  }

  // Get all study groups for current user
  Stream<List<StudyGroup>> getUserStudyGroups() {
    final currentUserID = auth.currentUser!.uid;

    return firestore
        .collection('study_groups')
        .where('memberIds', arrayContains: currentUserID)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        return StudyGroup.fromMap(doc.data() as Map<String, dynamic>, doc.id);
      }).toList();
    });
  }

  // Get all available study groups (for discovery)
  Stream<List<StudyGroup>> getAllStudyGroups() {
    return firestore.collection('study_groups').snapshots().map((snapshot) {
      return snapshot.docs.map((doc) {
        return StudyGroup.fromMap(doc.data() as Map<String, dynamic>, doc.id);
      }).toList();
    });
  }

  // Join a study group
  Future<void> joinStudyGroup(String groupID) async {
    try {
      final currentUserID = auth.currentUser!.uid;

      await firestore.collection('study_groups').doc(groupID).update({
        'memberIds': FieldValue.arrayUnion([currentUserID])
      });
    } catch (e) {
      print('Error joining study group: $e');
      rethrow;
    }
  }

  // Send a message to a study group
  Future<void> sendGroupMessage(String groupId, String message) async {
    try {
      final currentUserID = auth.currentUser!.uid;
      final currentUserEmail = auth.currentUser!.email!;
      final timestamp = Timestamp.now();

      final groupMessage = StudyGroupMessage(
        groupId: groupId,
        senderID: currentUserID,
        senderEmail: currentUserEmail,
        message: message,
        timestamp: timestamp,
      );

      await firestore
          .collection('study_groups')
          .doc(groupId)
          .collection('messages')
          .add(groupMessage.toMap());
    } catch (e) {
      print('Error sending group message: $e');
      rethrow;
    }
  }

  // Get messages for a study group
  Stream<List<StudyGroupMessage>> getGroupMessages(String groupId) {
    return firestore
        .collection('study_groups')
        .doc(groupId)
        .collection('messages')
        .orderBy('timestamp', descending: false)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        return StudyGroupMessage.fromMap(doc.data() as Map<String, dynamic>);
      }).toList();
    });
  }

  // Create a study session
  Future<void> createStudySession(String groupId, String title,
      DateTime startTime, DateTime endTime, String? notes,
      {bool isRecurring = false, String? recurrenceRule}) async {
    try {
      final currentUserID = auth.currentUser!.uid;

      final sessionData = StudySession(
        id: '', // Will be generated by Firestore
        groupId: groupId,
        title: title,
        startTime: Timestamp.fromDate(startTime),
        endTime: Timestamp.fromDate(endTime),
        organizerId: currentUserID,
        participantIds: [currentUserID],
        notes: notes,
        isRecurring: isRecurring,
        recurrenceRule: recurrenceRule,
      );

      final docRef =
          await firestore.collection('study_sessions').add(sessionData.toMap());
      await docRef.update({'id': docRef.id});

      // Get current user's name for notification
      final userDoc =
          await firestore.collection('users').doc(currentUserID).get();
      String organizerName = 'Someone';
      if (userDoc.exists) {
        final userData = userDoc.data() as Map<String, dynamic>;
        organizerName =
            userData['name'] ?? userData['email']?.split('@')[0] ?? 'Someone';
      }

      // Send notifications to all group members
      final NotificationService notiService = NotificationService();
      await notiService.sendSessionNotificationToGroupMembers(
        groupId: groupId,
        sessionTitle: title,
        organizerName: organizerName,
        startTime: startTime,
      );

      // Schedule notifications for session start and reminder
      await notiService.scheduleSessionStartNotifications(
        sessionId: docRef.id,
        groupId: groupId,
        sessionTitle: title,
        startTime: startTime,
        participantIds: [currentUserID], // Initially only the creator
      );
    } catch (e) {
      print('Error creating study session: $e');
      rethrow;
    }
  }

  // Get study sessions for a group
  Stream<List<StudySession>> getGroupSessions(String groupId) {
    return firestore
        .collection('study_sessions')
        .where('groupId', isEqualTo: groupId)
        .orderBy('startTime')
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        return StudySession.fromMap(doc.data() as Map<String, dynamic>, doc.id);
      }).toList();
    });
  }

  // Get all study sessions
  Stream<List<StudySession>> getAllSessions() {
    return firestore.collection('study_sessions').snapshots().map((snapshot) {
      return snapshot.docs.map((doc) {
        return StudySession.fromMap(doc.data() as Map<String, dynamic>, doc.id);
      }).toList();
    });
  }

  // Join a study session
  Future<void> joinStudySession(String sessionId) async {
    try {
      final currentUserID = auth.currentUser!.uid;

      // Add user to participant list
      await firestore.collection('study_sessions').doc(sessionId).update({
        'participantIds': FieldValue.arrayUnion([currentUserID])
      });

      // Get session details to schedule notifications for the new participant
      final sessionDoc =
          await firestore.collection('study_sessions').doc(sessionId).get();
      if (sessionDoc.exists) {
        final sessionData = sessionDoc.data() as Map<String, dynamic>;
        final session = StudySession.fromMap(sessionData, sessionId);

        // Schedule notifications for the new participant
        final NotificationService notiService = NotificationService();
        await notiService.scheduleSessionStartNotifications(
          sessionId: sessionId,
          groupId: session.groupId,
          sessionTitle: session.title,
          startTime: session.startTime.toDate(),
          participantIds: [currentUserID], // Only for this new participant
        );
      }
    } catch (e) {
      print('Error joining study session: $e');
      rethrow;
    }
  }

  // Send notification to group members
  Future<void> sendGroupNotification(
    String groupId,
    String title,
    String body,
  ) async {
    try {
      final NotificationService notiService = NotificationService();

      // Get group details
      final groupDoc =
          await firestore.collection('study_groups').doc(groupId).get();
      final groupData = groupDoc.data() as Map<String, dynamic>;
      final memberIds = List<String>.from(groupData['memberIds']);
      final currentUserID = auth.currentUser!.uid;

      // Send notification to each member
      for (final memberId in memberIds) {
        if (memberId != currentUserID) {
          // Don't notify the sender

          // Get member's device token for Firebase messaging
          final userDoc =
              await firestore.collection('users').doc(memberId).get();
          if (userDoc.exists) {
            final userData = userDoc.data() as Map<String, dynamic>;
            final deviceToken = userData['deviceToken'] as String?;

            // Send Firebase messaging notification if device token exists
            if (deviceToken != null && deviceToken.isNotEmpty) {
              await notiService.sendNotifications(body, title, deviceToken);
            }
          }

          // Store notification in Firestore
          await firestore
              .collection('users')
              .doc(memberId)
              .collection('notifications')
              .add({
            'title': title,
            'body': body,
            'groupId': groupId,
            'timestamp': FieldValue.serverTimestamp(),
            'isRead': false,
          });
        } else {
          // Send local notification to current user
          await notiService.showNotification(
            title: title,
            body: body,
          );
        }
      }
    } catch (e) {
      print('Error sending group notification: $e');
      rethrow;
    }
  }
}
